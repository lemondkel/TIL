## • getInstance()
➢ 싱글턴패턴, 하나의 인스턴스만 가지고 공유해서 쓴다  
➢ **싱글톤에서 유일하게 외부에서 객체를 얻는 방법**    
➢ 내부적으로 생성되지 않았다면 생성하고, 기존에 생성된 값이 존재하면 생성된 객체를 리턴하는 형태로 반환한다    
(= 없으면 만들고 있으면 있는거 리턴)  
➢ 여러 변수들은 싱글톤에서 동일한 객체를 참조하게 된다   

## • 싱글톤  
➢ 전체 프로그램에서 **단 하나의 객체**로만 만드는 경우가 있는데, 이 때의 객체를 **싱글톤**이라고 한다  

## • 싱글톤 패턴
➢ 어플리케이션이 시작될 때 어떤 클래스가 최초 한 번만 메모리를 할당하고 그 메모리에 인스턴스를 만들어 사용하는 디자인 패턴  
=> **객체의 인스턴스가 1개만 생성되는 패턴**  
➢ 주로 공통된 객체를 여러 개 생성해서 사용해야 하는 상황에 사용  
(데이터베이스에서 커넥션풀, 스레드풀, 캐시, 로그 기록 객체 등)

### 싱글톤 패턴 장점!!  
➢ 한 개의 인스턴스만 가져가므로 **메모리 절약** 가능(낭비 방지)  
➢ 다른 클래스 간에 **데이터 공유 쉬움** (싱글톤으로 만들어진 클래스의 인스턴스는 전역이라)    
➢ 두 번째 이용시부터는 객체 로딩 시간이 줄어 성능이 좋아짐  
➢ **요청이 많은 곳**에서 사용하면 **효율 높일** 수 있음  


### 싱글톤 패턴 단점!! 
➢ 싱글톤 인스턴스가 너무 많은 일을 하거나 많은 데이터를 공유시킬 경우, 다른 클래스의 인스턴스들 간에 결합도가 높아져 **"개방-폐쇄 원칙" 위배**  
-> 객체 지향 설계 원칙에 어긋나기 때문에 수정 어려워지고 유지 보수 비용 증가  
➢ 테스트하기 어려움  
-> 자원을 공유하기 때문에 **테스트가 결정적으로 격리된 환경에서 수행되려면** **매번 인스턴스의 상태 초기화시켜야 함**  
(초기화 안하면 전역에서 상태 공유하기 때문에 테스트 온전히 수행 불가)  
➢ 멀티스레드 환경에서 **동기화 처리 안하면 인스턴스 2개 생성될 수도**
=> 꼭 필요할 때만 쓰자!  
➢ **유연성 많이 떨어지**는 패턴임  

### 예제 1  
```
 public class Singleton {
    private static Singleton singleton = new Singleton();
    private Singleton() { }
    static Singleton getInstance() {
        return singleton;
    }
}
```
private로 해놔서 new로 변수 생성 불가  
```
public class Main {
    public static void main(String[] args) {
        // 외부 객체에서 값을 받아올때는 getInstance() 메소드를 사용
        Singleton obj1 = Singleton.getInstance();
        Singleton obj2 = Singleton.getInstance();

        if(obj1 == obj2){
            System.out.println("두 오브젝트는 같은 객체입니다.");
        }
        else{
            System.out.println("두 오브젝트는 다른 객체입니다.");
        }
    }
```
-> 결과 `두 오브젝트는 같은 객체입니다.`  

### 예제 2 
```
public class Car {
  private static Car car = new Car(); 
  // 자신을 멤버로 선언해서 메모리에 올려놓음 (static)
  private Car() {
    // 생성자는 외부에서 호출 못하게 private로 지정해야 함
  }
  public static Car getInstance(){
    return car;
  }
```



