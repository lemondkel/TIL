Redis
---

## • Redis  
➢ Ket, Value 구조의 비정형 데이터를 저장하고 관리하기 위한 오픈소스 기반의 비관계형 DBMS  
-> 데이터베이스, 캐시, 메세지 브로커로 사용되며 **인메모리 데이터 구조 가진 저장소**

&nbsp;  

### ❓ 굳이 Redis 사용하는 이유는!!?!?!?  
➢ DB는 데이터를 물리 디스크에 직접 씀!  
-> 때문에 서버에 문제 생겨 다운돼도 데이터 손실 X!!  
-> 하지만 매번 디스크에 접근해야 하기 때문에 사용자 많아질수록 부하 많아져 느려짐  
(운영 초반이거나 규모 작고 사용자 많지 않은 서비스는 무리가 가지 않음)  

=> 때문에 **사용자 늘어나면 DB가 과부하 될 수 있기 때문에 캐시 서버 도입해 사용**함!!  
=> 이 **캐시 서버로 이용**할 수 있는게 바로바로바로 **Redis**!!!!  

&nbsp;  

### ❓ 캐시가 뭐가 좋은데??  
➢ 캐시는 한 번 읽어온 데이터를 임의의 공간에 저장해, 다음에 읽을 때는 빠르게 결과를 받을 수 있게 해주는 공간!  
-> 같은 요청 여러 번 들어오면 매번 DB 거치지 않고 캐시 서버에서 첫 번째 요청 때 저장된 결과값을 바로 내려줌  
=> **DB 부하 줄이고 서비스 속도 느려지지 않음!!**  

### ☀︎ 즉, DB는 데이터를 물리 디스크에 직접 써서 데이터 손실 위험은 적지만, 사용자 많아질수록 부하가 많아지고 느려져서 이걸 해결하기 위해 Redis를 캐시 서버로 이용!  

&nbsp;  

## • 캐시 서버 패턴  
### ◦ Look aside cache  
> 1. 클라이언트가 데이터 요청
> 2. 웹서버는 데이터 존재하는지 Cache 서버에 먼저 확인
> 3. 존재하면 DB에 데이터 조회하지 않고 Cache 서버에 있는 결과값을 클라이언트에게 바로 반환 (Cache Hit)  
> 4. 존재하지 않으면 DB에 데이터 조회하여 Cache 서버 저장하고 결과값을 클라이언트에게 반환 (Cache Miss)

### ◦ Write Back
> 1. 웹서버는 모든 데이터를 Cache 서버에 저장
> 2. Cache 서버에 특정 시간 동안 데이터 저장됨
> 3. Cache 서버에 있는 데이터를 DB에 저장
> 4. DB에 저장된 Cache 서버의 데이터 삭제

-> 이 방식은 들어오는 데이터들이 저장되기 전에 메모리 공간에 머무르는데, 이때 서버에 장애 발생해 다운되면 데이터 손실될 위험 있음!

&nbsp;  

## • Redis 특징  
➢ Key, Value 구조라 쿼리 사용할 필요 X  
➢ 데이터를 디스크가 아닌 메모리에서 처리하여 속도 빠름  
➢ 싱글 스레드  
-> 한 번에 하나의 명령만 처리 가능  
-> 때문에 중간에 처리 시간 긴 명령 들어오면 그 뒤 명령어들은 대기 필요  
(get, set 명령어의 경우 초당 10만개 이상 처리할 수 있을 만큼 빠름!)  
➢ String, Lists, Sets, Sorted Sets, Hashes 자료구조 지원  
> **String** : 가장 일반적인 key-value 구조의 형태  
> **Sets** : String의 집합으로 여러 개의 값을 하나의 value에 넣기 가능  
> **Sorted Sets** : 중복된 데이터를 담지 않는 Set 구조에 정렬 Sort 적용한 구조 (랭킹 보드 서버 같은 구현에 사용)  
> **Lists** : Array 형식의 데이터 구조로, 처음과 끝에 데이터 넣고 빼는 건 빠르지만 중간에서는 어려움  

&nbsp;  

## • Redis 사용에 주의할 점  
➢ 서버에 장애 발생했을 경우엔 그에 대한 운영 플랜이 꼭 필요  
(인메모리 데이터 저장소의 특성상 서버에 장애 발생하면 데이터 유실 위험 있어서)  
➢ 메모리 관리 중요중요  
➢ 싱글 스레드이므로 처리하는데 시간이 오래 걸리는 요청/명령은 피하자!  






